{
  "hash": "f3568a985c8cb77b355ff7e3d6e6c0a3",
  "result": {
    "markdown": "---\ntitle: |\n  <b>プレゼミ2023</b> </br>\n  <span style=\"color: #282A36;\">第3回 Rの使い方・データ操作・可視化</span>\nauthor: \"Soichi Matsuura\"\nformat:\n  revealjs:\n    theme: [\"default\", \"dracula.scss\"]\n    transition: convex\n    slide-number: true\nhighlight-style: \"dracula\"\nexecute:\n  echo: true\n  warning: false\n---\n\n\n## 本日の講義内容\n\n\n第3回講義の**到達目標**は、\n\n- Posit Cloudにログインして、ブラウザ上でRstudioを使うことができる。\n- Visual Studio CodeでRのソースコードを書くことができる。\n- Visual Studio CodeでQuartoを使って、レポートや論文を書くことができる。\n- Rでデータを読み込み，データを加工し，グラフを作ることができる。\n\n## Rの基本操作\n\nまずは、`1+2`を計算してみます。\n\n\n::: columns\n::: {.column width=\"45%\"}\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-1_2250db7d734efb7b4c8fbceb6ce8a387'}\n\n```{.r .cell-code}\n1 + 2\n```\n:::\n\nと書いて、その行にカーソルがある状態で、`Ctrl + Enter`を押すと、\n:::\n::: {.column width=\"10%\"}\n:::\n::: {.column width=\"45%\"}\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-2_000292199a4c3a17ebb32c8d297c35ad'}\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\nという計算結果が表示されます。\n:::\n:::\n\n\n## よく使う基本関数\n- `+`加算，`-`減算, `/`除算, `*`乗算\n- `^`累乗, 2の2乗は`2^2`\n- `sqrt()`関数で平方根の計算\n- `c()`関数でベクトルの作成\n- `mean()`関数で平均を計算\n- `seq()`関数で数列の作成\n\n## パッケージ\n\nRはパッケージを使って機能を拡張することができます。\n\n- `install.packages()`関数でパッケージをインストールする。\n  - インストールしようとすると，どのサーバーからインストールするのか尋ねられるので，`TOKYO`のサーバーを選択するようにしましょう。\n- `library()`関数でパッケージを読み込む\n\n`install.pacakges()`が失敗するときは，RstudioあるいはR本体で`install.packages()`で実行してみる。\n\n## tidyverseパッケージ\n\n以下のコードを実行して、`tidyverse`をインストールしてください。\n`tidyverse`パッケージは，ある思想によって統一的なデザインで作成されたパッケージ群をインストールするものです。\n\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-3_d291f8f4510293c4b2660ba69cf108ed'}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\") # 最初の一回だけ実行\n```\n:::\n\nそして、以下のコードを実行して、`tidyverse`を読み込みます。\n\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-4_781a9aba308c1bac76fbcb053b5aec3c'}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n## 便利なパッケージ\n\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-5_47bb6c280d05fb81f505c11b66c9db9e'}\n\n```{.r .cell-code}\ninstall.packages(\"bloom\") # 結果の整形\ninstall.packages(\"ggthemes\") # グラフの見た目\ninstall.packages(\"modelsummary\") # 回帰結果の作表\ninstall.packages(\"kableExtra\") # 表の整形\ninstall.packages(\"gt\") # 表の整形\ninstall.packages(\"patchwork\") # グラフを並べて表示\n```\n:::\n\n\n## Githubとの連携\n\n- GitHubは、Gitというバージョン管理システムを使って、ソースコードのバージョン管理をクラウド上で行うことができる無料サービス\n- Visual Studio CodeはGit/GitHubとの連携も簡単\n- まずは、GitHubのウェブサイトにアクセスし、アカウントを作成してください。 [GitHub](https://github.com/)\n\n## Githubの学習\n\n:::{layout-ncol=3}\n![GitHubのオススメ本](./img/github_book01.jpg)\n\n![はじめてでもできるGitとGitHubの教科書](./img/github_book02.jpg)\n\n![わかばちゃんと学ぶGit使い方入門](./img/github_book03.jpg)\n:::\n\n## GitHub Copilotを使う\n\n- GitHub Copilotは、AIがコードの作成を支援してくれる超便利なツール\n- 学生は無料で利用できるので、プログラミングを学習しようとしている人は、導入の検討をしてみてください。\n\n[GitHub Copilot](https://copilot.github.com/)\n\n\n\n# Rによるデータ操作\n\n## 到達度検証のための課題\n\n1. CSVファイル、Excelファイルを読み込んで、中身を確認する。\n2. 必要なデータの抽出、変数の追加、変数の選択を行い、分析に適した形に持っていける。(`filter()`、`mutate()`,`select()`, `arrange()`, `pivot_longer()`, `pivot_wider()`)\n3. データ結合の種類を理解し、複数のデータを結合して、1つのデータフレームを作成する。(`bind_rows()`, `bind_cols()`, `left_join()`, `right_join()`, `inner_join()`, `full_join()`)\n\n## データの読み込み\n\n- 多くのプログラミング言語で、読み込むデータとして最も多いのが*CSV形式*のファイル\n- ファイルの拡張子は`.csv`\n- CSVとは、*C*omma *S*eparated *V*aluesの略で、カンマで区切られたデータのこと\n\n```\n企業ID,決算年月,売上高\n13,2020/03,1000\n13,2021/03,1200\n13,2022/03,1500\n24,2020/03,2000\n24,2021/03,2200\n```\n値とコンマ`,`のみで構成されたファイルのため、余計な情報が入っておらず、またファイルサイズも小さく、加工が簡単なので、データのやり取りによく使われます。\n\n<!--\n24,2022/03,2500\n33,2020/03,3000\n33,2021/03,3200\n33,2022/03,3500\n-->\n\n\n## 基本関数\n\n- 松浦のウェブサイトにあるデータ`keshohin_2023.csv`を読み込む\n- Rの場合は、基本関数`read.csv()`を使って、URLを直接指定して読み込む\n- 読み込んだデータを`df`という変数に代入する\n\n:::{.callout-important}\n## Rの場合\n\n`R`でcsvファイルを読み込む最もシンプルな方法は、基本関数`read.csv()`を用いて、ファイル名やファイルを参照するURLを直接指定することです。\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-6_b40a5d130d5d9dd7f72b457b5dc29df8'}\n\n```{.r .cell-code}\ndf <- read.csv(\"https://so-ichi.com/kesho_2023.csv\")\n```\n:::\n\n:::\n\n::: {.callout-tip}\n## MS Excelの場合\n\n1. URL`https://so-ichi.com/kesho_2023.csv`をブラウザに入力してファイルをダウンロードし、任意の場所に保存\n2. 「ファイル」から「開く...」をクリックして、保存したCSVファイルを選択し「開く」をクリック\n:::\n\n## Excelファイルの読み込み\n\nMS Excelのファイルは拡張子が`.xlsx`、古いMS Excelだと`.xls`です。\nRでExcelファイルを読み込むときは、`read_excel`という関数を使います。\nExcelファイルを用意するのが面倒なので、ここではこうやれば読み込めるよ、というコードだけ説明します。ファイル名は`hoge.xlsx`とします。\n\n:::{.callout-important}\n## Rの場合\n\n`R`でMS Excelのファイルを読み込むには、`readxl`パッケージの`read_excel()`関数を用います。\n\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-7_22fb609e28164ca1f6f5c7b15845abfd'}\n\n```{.r .cell-code}\ndfx <- readxl::read_excel(\"hoge.xlsx\")\n```\n:::\n\n:::\n\n::: {.callout-tip}\n## MS Excelの場合\n\n1. 「ファイル」から「開く...」をクリックし、保存してあるExcelファイルを選択し「開く」をクリック\n:::\n\nMS Excelの問題点は、目的のデータがどのExcelファイルに入っていて、それがどこに保存されているのかを覚えておかないと、いちいちファイルを開いて探さないといけないことです。\n\nRだとソースコードを残すことができますので、\nどこにあるファイルを読み込んで、そこに何が入っているのかをコメントで残しておくことができます。\n\n## 読み込んだデータの確認\n\nMS Excelは読み込んだデータが画面上に表として表示されていますが、Rでは変数に代入しただけでは、画面には何も表示されません。\nそこでデータの中身を確認する関数として、次のようなものがあります。\n\n- `head()` : 最初の数行を表示させる基本関数\n- `str()` : データの構造を表示させる基本関数\n- `glimpse()` : データの構造を表示させるdplyrパッケージの関数\n- `names()` : 変数名を表示させる基本関数\n\nこれらを使って、データの中身を確認し、データの形に適した処理方法を学ぶ必要があります。\n以下では、`head()`関数を使って、データの最初の数行を表示させてから、`str()`関数でデータの中の変数とその型を確認します。\n\nExcelは目視が中心ですが、見ただけでは、文字列なのか数なのかが分からないので、やはりデータの型は確認する必要があります。\n\n:::{.callout-important}\n## Rの場合\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-8_b0ca8ee2f9edc451896969e7446e3aa5'}\n\n```{.r .cell-code}\nhead(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  code   name    term shubetsu ren  sales netincome month\n1  641 資生堂 1985/11       10   1 371040     14526    12\n2  641 資生堂 1986/11       10   1 375294     13632    12\n3  641 資生堂 1987/11       10   1 378977      9014    12\n4  641 資生堂 1988/11       10   1 401311      9515    12\n5  641 資生堂 1989/03       10   1 130654      4265     4\n6  641 資生堂 1990/03       10   1 456352     11362    12\n```\n:::\n\n```{.r .cell-code}\nstr(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t130 obs. of  8 variables:\n $ code     : int  641 641 641 641 641 641 641 641 641 641 ...\n $ name     : chr  \"資生堂\" \"資生堂\" \"資生堂\" \"資生堂\" ...\n $ term     : chr  \"1985/11\" \"1986/11\" \"1987/11\" \"1988/11\" ...\n $ shubetsu : int  10 10 10 10 10 10 10 10 10 10 ...\n $ ren      : int  1 1 1 1 1 1 1 1 1 1 ...\n $ sales    : int  371040 375294 378977 401311 130654 456352 517252 553299 561549 549178 ...\n $ netincome: int  14526 13632 9014 9515 4265 11362 15850 16011 13290 14668 ...\n $ month    : int  12 12 12 12 4 12 12 12 12 12 ...\n```\n:::\n:::\n\n:::\n\n::: {.callout-tip}\n## MS Excelの場合\n\n画面を見て確認する。\n\n:::\n\nこのデータには，\n\n- `code` : 企業コード (文字列)\n- `name` : 企業名 (文字列)\n- `term` : 決算年月 (文字列)\n- `shubetsu` : 会計基準の種類 (数値)\n- `ren` : 連結か単体 (数値)\n- `sales` : 売上高 (数値)\n- `netincome` : 当期純利益 (数値)\n- `month` : 決算月数 (数値)\n\nが入っています。\n\n## データの整形\n\n### データ操作の基礎\n\nさあ面白くなってきました。\n次はデータを操作していきます。\nRによるデータ操作では、`tidyverse`パッケージ群の`dplyr`パッケージが大活躍します。\n\n`dplyr`パッケージの関数の中でもよく使うものに次のようなものがあります。\n\n- `select()` : 変数を選択する\n- `filter()` : データを抽出する\n- `mutate()` : 変数を追加する\n- `arrange()` : データを並び替える\n- `summarise()` : データを集計する\n- `group_by()` : データをグループ化する\n\n### パイプ演算子\n\nRでソースコードを書く際に，理解しやすく，読みやすいコードにするために非常に便利なのが，パイプ演算子`%>%`です。\nパイプ演算子`%>%`は，左側のオブジェクトを右側の関数の第一引数に渡すという処理を行います。\nたとえば，\n\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-9_62a1749751dbfa2db793cddf3189270a'}\n\n```{.r .cell-code}\n(1 + 2) %>% sqrt()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.732051\n```\n:::\n:::\n\nと書くと，`sqrt(1 + 2)`と同じ意味になります。\nたとえば，`rnorm()`関数を使って平均0，分散1の標準正規分から100個のデータを作りたいとします。\n`rnorm()`関数は3つの引数を取ります。\n\n1. データの個数\n2. 平均\n3. 標準偏差\n\nしたがって，`rnorm(100, 0, 1)`と書くと，平均0，分散1の標準正規分布から100個のデータを取り出すことができます。\nパイプ演算子を使うと，\n\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-10_6aff62ea22f41b97d1ab69a04a274376'}\n\n```{.r .cell-code}\n100 %>% rnorm(mean = 0, sd = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] -1.3572553505 -0.7710737632 -0.6618599624 -0.7988408388  1.0090618543\n  [6] -0.3340209277  0.0896193000 -0.9493523195 -0.7184733584  0.8432990507\n [11] -0.7044685529  0.1989936683  0.1327002721  0.7296222909  2.1343530120\n [16]  0.6069824654  1.3135631689 -0.0682697473  0.0795486352 -0.4865497909\n [21]  0.2793662569 -0.7318499328  1.9948081293 -0.5240042896  0.6693724106\n [26] -0.1373570576  0.3975494475 -1.1730883943  0.5804554912  2.0022448469\n [31] -1.1922907504  0.5263405922 -0.8672897422 -0.7023260588  0.9850621053\n [36] -1.1937999304  1.0510909486 -0.7409995833  1.4609294835  0.2603021735\n [41] -0.5999882475  0.0004803921  1.5092805619 -0.3160982542 -1.2363750464\n [46]  0.3284615757  0.5450226068  0.7219884196  0.2583883443  1.7591655239\n [51]  1.0704835073 -0.5982507043 -0.2333814875 -0.7108978513  2.0642714308\n [56] -0.5108413970  1.0622618395 -0.6484187888  0.1223635187 -0.9351548591\n [61]  1.4356191524  0.5092783644 -0.1540087426 -0.0735818383  1.5789669637\n [66] -1.4464017347 -1.2063420363 -0.4591683164  1.3615933190 -1.1620947816\n [71]  0.0186081714  0.9715703055  0.4629084237  0.2247816418 -1.1321945087\n [76]  1.1269195608 -0.3608907292 -0.2676031527  1.1731795574  1.2457239013\n [81] -0.1024710845 -0.8016963010  0.0278880220 -1.3034185402 -0.3291029627\n [86] -1.3772863846  1.1300791759  0.8917810987 -0.5398358405  0.4477120872\n [91]  1.8356142653  0.7915008872 -0.7114711412 -1.5891088971  0.0985616526\n [96]  0.8965806004  0.9400073499 -0.0633376656  0.1656677422 -1.7665200226\n```\n:::\n:::\n\nとなります。\nこれは`rnorm()`関数の第1引数がデータの個数なので，そこに`100`を渡しています。\nここで平均に値を渡したい場合を考えます。\n`mean`引数は第2引数なので，パイプ演算子では自動で渡してくれません。\nそこで`.`を使って渡す場所を指定してあげます。\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-11_6c561e13f0d69b6135b9765cff31d48d'}\n\n```{.r .cell-code}\n100 %>% rnorm(100, mean =. , sd = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] 101.54154 101.42682  99.16352  99.33611 101.11846  99.04617  98.85759\n  [8]  99.93556 100.87995  99.45036  99.57699  99.39648 100.15111 100.40291\n [15] 100.17771  98.56418 101.59425 100.94427  99.69069  99.97026  99.83996\n [22]  98.85857  99.84139 101.99454 100.72582 100.47747 100.11478  98.64631\n [29]  98.62543 100.54695 100.25609  99.69065 100.66338  99.70592 100.74064\n [36]  99.44869  99.35655 100.35448 101.88179  99.46124 101.34836  99.45882\n [43]  99.89461 100.87687  99.49584  98.95390  99.99676  99.93280  99.78675\n [50]  98.46170 100.22099 101.04299 100.44883 100.65190  99.35712 100.91358\n [57] 101.39737  99.36175 100.41494  99.87025  98.98592  99.95083  99.69378\n [64]  99.67338  98.85939  99.63679  99.05609  99.04185 100.91275 100.14250\n [71]  99.82527  99.72951 100.72688  99.01809 100.85382 101.06089 100.75543\n [78]  99.40094  99.20164  98.08326 101.39560 100.26022 100.51790  99.99096\n [85]  99.41935 100.51489 101.44580  98.89688  98.37876 100.64436  99.45143\n [92]  98.85579  99.76324 100.84385  99.95757  99.27428  97.54577 100.81094\n [99]  99.70464  99.52319\n```\n:::\n:::\n\nこれで平均100，標準偏差1の正規分布から100個のデータを取り出せました。\n\n\nこれだけだとパイプ演算子`%>%`の便利さが伝わらないので，たとえば次のような処理を考えてみましょう。\n\n1. 2020年のデータを抜き出し，\n2. 売上高当期純利益率を計算し，\n3. 産業グループごとに平均を計算する\n4. 利益率が高い順番に並び替える\n\nをパイプ演算子を使って書くと，\n\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-12_a42cf20cdd85204b1feb2110d962bff9'}\n\n```{.r .cell-code}\ndf <- df %>%\n    filter(term == \"2020\") %>% # 2020年のみ\n    mutate( # 新しい変数を作成\n        ratio = netincome / sales # 売上高利益率\n        ) %>%\n    group_by(sangyo) %>% # 産業グループごとに\n    summarise( # 平均を計算\n        mean_ratio = mean(ratio) # 利益率の平均\n        ) %>%\n    arrange(desc(mean_ratio)) # 利益率の高い順に並び替え\n```\n:::\n\nのように，上から順番に処理を実行し，次に渡す，というプロセスが分かりやすく，読みやすいコードができました。\nコメントも残しておけば，後から見返したときにも分かりやすいですし，他人によんでもらうときも親切ですね。\nしたがって，以下ではパイプ演算子を駆使して，データ操作を行っていきます。\n\n\n### 新しい変数を作成する `mutate` {.unnumbered}\n\n新しい変数を作成するには，`dplyr`パッケージの`mutate()`関数を使います。\n先ほど読みこんだデータから，当期純利益を売上高で除して売上高当期純利益率を計算して，`ratio`という変数を作ってみましょう。\n\n:::{.callout-important}\n## Rの場合\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-13_01c602f1d1ce29357555e039bfc2d179'}\n\n```{.r .cell-code}\ndf <- df %>%\n    mutate( # 新しい変数を作成\n        ratio = netincome / sales # 売上高利益率\n        )\n```\n:::\n\n:::\n\n::: {.callout-tip}\n## MS Excelの場合\n\n`I1`のセルに変数名を表す`ratio`と入力する。\nF列の`sale`とG列の`netincome`を使って，`I2`のセルに\n\n`= G2 / F2`\n\nとし，`I2`セルの右下の四角をダブルクリックすると，自動で下のセルにも同じ計算がコピーされる。\n:::\n\n次に，ある変数の値に応じて異なる値をとる変数を作るには，`mutate()`関数と`ifelse()`関数を同時に使います。`ifelse()`関数は次のような引数を取ります。\n\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-14_148f4efcdcbf0e39420f4e5b30370b3c'}\n\n```{.r .cell-code}\nifelse(条件, 条件が真のときの値, 条件が偽のときの値)\n```\n:::\n\n\n先ほど計算した売上高当期純利益率が5%以上ならば「高い」，そうでなければ「低い」という変数`highlow`を作ってみましょう。\n\n:::{.callout-important}\n## Rの場合\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-15_f4a5e969600aa7a14fa7ee68228f2b9d'}\n\n```{.r .cell-code}\ndf <- df %>%\n    mutate( # 新しい変数を作成\n        highlow = ifelse(ratio >= 0.05, \"高い\", \"低い\") # 売上高利益率\n        )\n```\n:::\n\n:::\n\n::: {.callout-tip}\n## MS Excelの場合\n`J1`セルに`highlow`と入力する。\n`J2`セルに\n\n` = if(I2 >= 0.05, \"高い\", \"低い\")`\n\nと入力し，`J2`セルの右下の四角をダブルクリックすると，自動で下のセルにも同じ計算がコピーされる。\n:::\n\nExcelだとセルの移動や変数名の入力，計算式の入力，セルのコピーといった作業で，キーボードとマウスを行ったり来たりする必要があり，若干面倒です。\n\nついでに，`mutate()`関数を使って，長すぎる企業名を短くしてみます。\nここでは「ポーラ・オルビスホールディングス」を「ポーラ」と略してみます。\n`mutate()`と`ifelse`を使って，`name`変数の値が「ポーラ・オルビスホールディング」ならば「ポーラ」という値をとる変数`name`上書きします。を作ってみましょう。\n\n:::{.callout-important}\n## Rの場合\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-16_e81df05ddf1a0f542579b58c20c89914'}\n\n```{.r .cell-code}\ndf <- df %>%\n    mutate( # 新しい変数を作成\n        name = ifelse(\n            name == \"ポーラ・オルビスホールディング\", \"ポーラ\", name) # 企業名\n        )\n```\n:::\n\n:::\n\n\n### データを抽出する `filter` {.unnumbered}\n\nデータを抽出するには，`dplyr`パッケージの`filter()`関数を使います。\n`filter()`関数は，次のような引数を取ります。\n\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-17_1690c874cb0f7c2241cbabf04aa6a4ee'}\n\n```{.r .cell-code}\nfilter(データ, 条件)\n```\n:::\n\n\n先ほど作成した`ratio2`が「高い」企業だけを抽出してみましょう。\n`filter()`関数の中の条件は，`==`を使って，`\"高い\"`という文字列と一致するかどうかを確認しています。\nここでは，`highlow`変数の値が`\"高い\"`と一致する企業だけを抽出し，`df_high`という変数に代入しています。\n\n:::{.callout-important}\n## Rの場合\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-18_be9036285f8c1fa142f1d916a7717f3c'}\n\n```{.r .cell-code}\ndf_high <- df %>%\n    filter(highlow == \"高い\") # 条件\n```\n:::\n\n:::\n\n::: {.callout-tip}\n## MS Excelの場合\nhighlow変数のあるJ列をクリックして枠を移動させ，上の「ホーム」メニューから「並び替えとフィルター」をクリックし，「フィルター」をクリックする。\nすると，変数名highlowのヨコに漏斗のようなマークが出るので，それをクリックすると，記録されたデータの種類が出てくるので，「高い」だけにチェックが入った状態にする。\n:::\n\nExcelのクリック回数が増えてきましたね。\n\n`filter()`関数の中で指定する条件は，\n\n- `==` : 一致する\n- `!=` : 一致しない\n- `>=`や`<=` : 以上や以下\n- `>`や`<` : より大きいや小さい\n- `%in%` : いずれかに一致する\n\nなどがあります。またこれらの条件を組み合わせることもできます。\nその場合は，以下のように`&`や`|`を使います。\n\n- `&` : かつ\n- `|` : または\n\nたとえば，資生堂と花王を抽出したり，売上高当期純利益率が5%以上かつ売上高が1000億円以上の企業を抽出するには，\n次のように書きます。\n\n:::{.callout-important}\n## Rの場合\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-19_a4f403b8ad05053a06290e5049b61709'}\n\n```{.r .cell-code}\ndf_shiseido_kao <- df %>%\n    filter(name %in% c(\"資生堂\", \"花王\")) # 2社だけ抽出\ndf_high2 <- df %>%\n    filter(ratio >= 0.05 & sales >= 1000) # 2条件を同時に満たす\n```\n:::\n\n:::\n\n\n\n### 変数を選択する `select` {.unnumbered}\n\nデータの中から必要な変数だけを選択するには，`dplyr`パッケージの`select()`関数を使います。\nたとえば，先ほど作成した`df`から，企業コード，企業名，売上高当期純利益率の3つの変数だけを選択してみましょう。\n\n:::{.callout-important}\n## Rの場合\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-20_88c9433f00223bc72c76101d3d8f2221'}\n\n```{.r .cell-code}\ndf3 <- df %>%\n    select(code, name, ratio) # 3つの変数だけ選択\n```\n:::\n\n:::\n\n::: {.callout-tip}\n## MS Excelの場合\nオリジナルのデータをコピーして，下のタブから別のシートを選択し，そこに貼り付ける。\n\n貼り付けたデータから`code`と`name`と`ratio`以外の列を削除する。\n:::\n\nMS Excelだと，不要なデータを削除するのが怖い作業で，必要になったときにまた元のデータを読み込まないといけないので，面倒ですし，ミスのもとです。\n\n`select()`関数の中で使えるものには，以下のようなものがあります。\nとても便利なので，覚えておくとよいでしょう。\n\n- `-` : 除外する (`-ratio`とかくと`ratio`以外を選択)\n- `:` : 連続する変数を選択 (`code:ren`と書くと`code`から`ren`までを選択)\n- `starts_with()` : ある文字列で始まる変数を選択\n- `ends_with()` : ある文字列で終わる変数を選択\n\nたとえば，`mutate()`で新しい変数を作る場合に，変数名に法則性をつけておけば，`starts_with()`を使って一気に変数を選択することができます。\nたとえば，比率を表す変数は`ratio`で始まるように統一しておく，基準化した変数には`_K`を最後に付けておく，などです。\n\n### データを並び替える `arrange` {.unnumbered}\n\nデータを並び替えるには，`dplyr`パッケージの`arrange()`関数を使います。\nたとえば，先ほど作成した`df`から，売上高当期純利益率を並び替えてみましょう。\n\n:::{.callout-important}\n## Rの場合\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-21_295fc4227162906f268016f5e10f2478'}\n\n```{.r .cell-code}\ndf %>%\n    select(name, ratio) %>% # 2つの変数だけ選択\n    arrange(ratio) %>%\n    head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    name       ratio\n1 ポーラ -0.43495809\n2 資生堂 -0.07576384\n3 資生堂 -0.03859062\n4 資生堂 -0.02166802\n5 資生堂 -0.01384122\n6 資生堂 -0.01266169\n```\n:::\n:::\n\n:::\n小さい順に並び替えられました。\n大きい順にするには，`desc()`関数を使います。\nついでに`knitr`パッケージの`kabble()`関数で表を見やすく加工してみます。\n\n:::{.callout-important}\n## Rの場合\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-22_6e2bcc17fbd33f9bff8bd1375a73ab30'}\n\n```{.r .cell-code}\ndf %>%\n    select(name, ratio) %>% # 2つの変数だけ選択\n    arrange(desc(ratio)) %>%\n    head(10) %>% # 先頭の10行\n    knitr::kable(booktabs = TRUE) # 表をきれいに表示\n```\n\n::: {.cell-output-display}\n|name           |     ratio|\n|:--------------|---------:|\n|ポーラ         | 0.1110647|\n|花王           | 0.1019213|\n|花王           | 0.0987028|\n|花王           | 0.0986613|\n|ユニ・チャーム | 0.0929384|\n|花王           | 0.0912752|\n|ポーラ         | 0.0895507|\n|ユニ・チャーム | 0.0891383|\n|ユニ・チャーム | 0.0890311|\n|ユニ・チャーム | 0.0869777|\n:::\n:::\n\n:::\nこれでどの企業のどの年度の売上高当期純利益率が大きいのかが一目瞭然になりました。\n\nMS Excelだと，\n\n::: {.callout-tip}\n## MS Excelの場合\n\n「ホーム」メニューから「並び替えとフィルター」をクリックし，「昇順」をクリックする。\n\n必要なデータだけ選択してコピペすれば，表が完成します。\n:::\n\nとなります。\n簡単ですが，MS Excelの並び替えは注意が必要で，並び替えた後にデータを追加すると，並び替えが解除されてしまい，元に戻せなくなったり，空列があると並び替えがうまくいかなかったりします。\n\n\n### long形式とwide形式\n\n人間には読みやすいけれどパソコンは読みにくい，というデータの形式があります。\n例えば下の表を見てみましょう。\n\n| 地点 |   6時    |   12時   |   18時   |\n|:----:|:--------:|:--------:|:--------:|\n| 札幌 | 12℃  | 15℃  | 13℃  |\n| 大阪 | 20℃  |  24℃  |  22℃  |\n| 福岡 |  23℃  | 25℃  | 25℃  |\n\nこのような形のデータをワイド形式(wide)といいます。\n天気予報で見かけそうなこの表は，人間にとっては分かりやすいですが，実はコンピュータにとっては，分かりにくいものです。\nコンピュータが理解しやすいデータとして表すなら，次のような表になります。\n\n| 地点 | 時間 |  気温(℃) |\n|:----:|:----:|:-------:|\n| 札幌 | 6時  |   12    |\n| 札幌 | 12時 |   15    |\n| 札幌 | 18時 |   13    |\n| 大阪 | 6時  |   20    |\n| 大阪 | 12時 |    24    |\n| 大阪 | 18時 |    22    |\n| 福岡 | 6時  |    23    |\n| 福岡 | 12時 |   25    |\n| 福岡 | 18時 |   25    |\n\nこのような形式のデータをロング型(long)といいます。\nこのロング型のうち，一定のルールに従って作成されたデータを**整然データ(tidy data)**といい，Rでは，この整然データを扱うことが多いです。\n\nR神Hadley Wickham氏は，データの型を理解することを，データ分析の第一歩とし，その一貫として整然データという考え方を提唱しています。 整然データとは，次のような原則に従って構築されたデータのことです(Wickham, 2014) 参考[https://id.fnshr.info/2017/01/09/tidy-data-intro/](https://id.fnshr.info/2017/01/09/tidy-data-intro/)。\n\n1.  個々の変数 (variable) が1つの列 (column) をなす。\n2.  個々の観測 (observation) が1つの行 (row) をなす。\n3.  個々の観測の構成単位の類型 (type of observational unit) が1つの表 (table) をなす。\n4.  個々の値 (value) が1つのセル (cell) をなす\n\n上の表は，地点，時間，天気，気温の4つの変数があり1つの列をつくっています(ルール1)。 大阪12時の天気は雨，気温は12℃といったように1つの行が1つの観測を表しています(ルール2)。 このデータには種類の異なる観測はない(ルール3)。 また，各セルには1つの値が入っています(ルール4)。 よって，これが整然データとなります。\n\n上のロング型の天気データを使って，ロングからワイド，ワイドからロングの操作を学びましょう。\n\nまずデータを作ります。\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-23_12507264301d9190b0a8d8b1edea879c'}\n\n```{.r .cell-code}\ndf_weather <- data.frame(\n    place = c(\"札幌\",\"札幌\",\"札幌\",\"大阪\",\"大阪\",\"大阪\",\"福岡\",\"福岡\",\"福岡\"), # 各地を3個ずつ\n    time = rep(c(\"6時\", \"12時\", \"18時\"),3),\n    temp = c(12,15,13,20,24,22,23,25,25)\n)\nprint(df_weather)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  place time temp\n1  札幌  6時   12\n2  札幌 12時   15\n3  札幌 18時   13\n4  大阪  6時   20\n5  大阪 12時   24\n6  大阪 18時   22\n7  福岡  6時   23\n8  福岡 12時   25\n9  福岡 18時   25\n```\n:::\n:::\n\n\nこれはロング型の整然データとなります。\n\n### ロングからワイド `pivot_wider` {.unnumbered}\n\nRで使うならこのままでよいのですが，あえてこれをワイド型に変えてみましょう。\n\n教科書で使用されている`spread()`は「根本的に設計ミスってた」と公式で発表されているので，R神が作った`pivot_wider()`を使います。widerという名前の通り，ワイド型に変換する関数です。\n\n`pivot_wider()`の引数は，`names_from`と`values_from`です。`names_from`は，ワイド型に変換するときに，どの変数を列にするかを指定します。`values_from`は，ワイド型に変換するときに，どの変数の値を使うかを指定します。\n\n以下のコードでは，`time`変数の値を列に，`temp`変数の値を値にして，`df_wide`という変数に代入しています。\n\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-24_01d9ea6ee35f2b4f2771a7de8e7f3ac9'}\n\n```{.r .cell-code}\ndf_wide <- df_weather %>%\n    pivot_wider(names_from = time, values_from = temp)\nprint(df_wide)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 4\n  place `6時` `12時` `18時`\n  <chr> <dbl>  <dbl>  <dbl>\n1 札幌     12     15     13\n2 大阪     20     24     22\n3 福岡     23     25     25\n```\n:::\n:::\n\n\nこれでワイド型に変換できました。\n\n### ワイドからロング `pivot_longer` {.unnumbered}\n\n\n次に，このワイド型のデータをロング型に変換してみます。\n教科書では，`tidyr`の`gather()`を使っていますが，これも`wider()`と同じ問題を持っているので，R神による`pivot_longer()`を使います。\n\n`pivot_longer()`の引数は，`cols`と`names_to`と`values_to`です。\n\n- `cols`は，ロング型に変換するときに，どの変数を行にするかを指定\n- `names_to`は，ロング型に変換するときに，どの変数の値を使うかを指定\n- `values_to`は，ロング型に変換するときに，どの変数の値を使うかを指定\n\n以下のコードでは，`6時`，`12時`，`18時`の3つの変数を行に，`time`という変数の値を列に，`temp`という変数の値を値にして，`df_long`という変数に代入しています。\n\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-25_b81314ff3a41fd044042bbae8d9053e8'}\n\n```{.r .cell-code}\ndf_long <- df_wide %>%\n    pivot_longer(\n        cols = c(\"6時\", \"12時\", \"18時\"), # 縦にする変数\n        names_to = \"time\", # 縦にした変数名\n        values_to = \"temp\") # 値\nprint(df_long)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 3\n  place time   temp\n  <chr> <chr> <dbl>\n1 札幌  6時      12\n2 札幌  12時     15\n3 札幌  18時     13\n4 大阪  6時      20\n5 大阪  12時     24\n6 大阪  18時     22\n7 福岡  6時      23\n8 福岡  12時     25\n9 福岡  18時     25\n```\n:::\n:::\n\n\n元のロング型に戻りました。\n\n### データの結合\n\n別々のデータを結合させて使いたいことはよくあります。\n例えば，次のようなデータを結合させる場合を考えてみましょう。\n\n#### 表A {.unnumbered}\n\n| name | term | sale |\n|:----|----:|----:|\n|トヨタ | 2020 | 1000 |\n|トヨタ | 2021 | 900 |\n|トヨタ | 2022 | 1400 |\n|ホンダ | 2020 | 800 |\n|ホンダ | 2021 | 700 |\n|ホンダ | 2022 | 900 |\n\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-26_a0af33970a0a531540dd0c0f6eac00b4'}\n\n```{.r .cell-code}\ndf_A <- data.frame(\n    name = c(\"トヨタ\", \"トヨタ\", \"トヨタ\", \"ホンダ\", \"ホンダ\", \"ホンダ\"),\n    term = c(2020, 2021, 2022, 2020, 2021, 2022),\n    sale = c(1000, 900, 1400, 800, 700, 900)\n)\n```\n:::\n\n\n#### 表B {.unnumbered}\n\n| name | term | sale |\n|:----|----:|----:|\n|日産 | 2020 | 400 |\n|日産 | 2021 | 500 |\n|日産 | 2022 | 900 |\n|マツダ | 2020 | 300 |\n|マツダ | 2021 | 400 |\n|マツダ | 2022 | 200 |\n\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-27_fc6fc449c75af1ea8324cc83d60c5dcc'}\n\n```{.r .cell-code}\ndf_B <- data.frame(\n    name = c(\"日産\", \"日産\", \"日産\", \"マツダ\", \"マツダ\", \"マツダ\"),\n    term = c(2020, 2021, 2022, 2020, 2021, 2022),\n    sale = c(400, 500, 900, 300, 400, 200)\n)\n```\n:::\n\n\n#### 表C {.unnumbered}\n\n| name | term | netincome |\n|:----|----:|----:|\n|トヨタ | 2020 | 100 |\n|トヨタ | 2021 | 90 |\n|トヨタ | 2022 | 150 |\n|ホンダ | 2020 | 140 |\n|ホンダ | 2021 | 100 |\n|ホンダ | 2022 | 90 |\n|スバル | 2020 | 30 |\n|スバル | 2021 | 35 |\n|スバル | 2022 | 50 |\n\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-28_516470d2a3ae3b497dbcb8824570e7f0'}\n\n```{.r .cell-code}\ndf_C <- data.frame(\n    name = c(\"トヨタ\", \"トヨタ\", \"トヨタ\", \"ホンダ\", \"ホンダ\", \"ホンダ\", \"スバル\", \"スバル\", \"スバル\"),\n    term = c(2020, 2021, 2022, 2020, 2021, 2022, 2020, 2021, 2022),\n    netincome = c(100, 90, 150, 140, 100, 90, 30, 35, 50)\n)\n```\n:::\n\n\n\nこの3つのデータを結合させる場合を考えます。\nまず表Aと表Bは同じ変数をもつデータなので，これらを結合させるには，縦につなげる必要があります。\nこのような結合を**縦結合**とか連結といいます。\n縦結合は，`dplyr`パッケージの`bind_rows()`関数を使います。\n\n\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-29_3745ba5a7a63ef951ef531739e106b85'}\n\n```{.r .cell-code}\ndf_AB <- bind_rows(df_A, df_B)\nprint(df_AB)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     name term sale\n1  トヨタ 2020 1000\n2  トヨタ 2021  900\n3  トヨタ 2022 1400\n4  ホンダ 2020  800\n5  ホンダ 2021  700\n6  ホンダ 2022  900\n7    日産 2020  400\n8    日産 2021  500\n9    日産 2022  900\n10 マツダ 2020  300\n11 マツダ 2021  400\n12 マツダ 2022  200\n```\n:::\n:::\n\n縦に結合できたので，トヨタ，ホンダ，日産，マツダのデータが入ったデータベース`df_AB`ができました。\n\n次に，この`df_AB`と`df_C`を結合させます。\n`df_C`は`netincome`という`df_AB`にはない変数があり，異なる変数をもつデータ同士の結合となります。\nこれらを結合させるには，横につなげる必要があります。\nこのような結合を**結合**といいます。\n\n結合には，\n\n- **内部結合**(inner join)\n- **外部結合**(outer join)\n\nがあり，外部結合には，\n\n- **完全結合**(full join)\n- **左結合**(left join)\n- **右結合**(right join)\n\nがあります。\n\n内部結合は**両方のデータベースに存在する観測値のみを保持**するため，多くのデータが欠落することになりますが，**外部結合**は、少なくとも1つのテーブルに存在する観測値を保持するので，大部分のデータが欠落することにはなりません。\n\n3つの外部結合の特徴は次の通りです。\n\n- **完全結合**は、xとyのすべての観測値を保持します。\n- **左結合**は、xのすべての観測値を保持します。\n- **右結合**は、yのすべての観測値を保持します。\n\nR神の神書籍[R for Data Science (2e)](https://r4ds.hadley.nz/)の図がわかりやすいので，ここで紹介します。\n\n![外部結合の例](img/R4D_join.png)\n\n内部結合と3つの外部結合をベン図で表すとこうなります。\n\n![外部結合のベン図](img/R4D_outer_join.png)\n\n最もよく使われる結合は**左結合**です。\n元データに他のデータを結合する場合，元データに含まれるデータのみ保持したい場合が多いので，追加データを調べるときはいつもこれを使います。\n左結合はデフォルトの結合であるべきで、他の結合を選択する強い理由がない限り、これを使用します。\n\nでは，`df_AB`と`df_C`を左結合してみましょう。\n結合する際にキーとなる変数を指定する必要があります。\nここでは`name`と`term`の2つの変数をキーとして指定します。\nこうすることで，`name`と`term`が一致する観測値を結合します。\n\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-30_471467c140bbccec0cbcf23d8a8eec79'}\n\n```{.r .cell-code}\ndf_left <- df_AB %>%\n    left_join(df_C, by = c(\"name\", \"term\"))\nprint(df_left)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     name term sale netincome\n1  トヨタ 2020 1000       100\n2  トヨタ 2021  900        90\n3  トヨタ 2022 1400       150\n4  ホンダ 2020  800       140\n5  ホンダ 2021  700       100\n6  ホンダ 2022  900        90\n7    日産 2020  400        NA\n8    日産 2021  500        NA\n9    日産 2022  900        NA\n10 マツダ 2020  300        NA\n11 マツダ 2021  400        NA\n12 マツダ 2022  200        NA\n```\n:::\n:::\n\n\n`df_AB`にはトヨタ，ホンダ，日産，マツダのデータがありますが，`df_C`には日産とマツダのデータがなく，スバルのデータがあります。\nそのため左結合すると，日産とマツダの`netincome`には`NA`が入り，スバルは欠落します。\n\n\n`df_AB`と`df_C`を右結合してみましょう。\n\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-31_7df7fdd0c08e7a5d82adef656467d4f6'}\n\n```{.r .cell-code}\ndf_right <- df_AB %>%\n    right_join(df_C, by = c(\"name\", \"term\"))\nprint(df_right)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    name term sale netincome\n1 トヨタ 2020 1000       100\n2 トヨタ 2021  900        90\n3 トヨタ 2022 1400       150\n4 ホンダ 2020  800       140\n5 ホンダ 2021  700       100\n6 ホンダ 2022  900        90\n7 スバル 2020   NA        30\n8 スバル 2021   NA        35\n9 スバル 2022   NA        50\n```\n:::\n:::\n\n\n`df_C`には日産とマツダのデータがなく，トヨタとホンダとスバルのデータがあります。\nそのため右結合すると日産とマツダのデータが欠落し，`df_C`に含まれていたトヨタ，ホンダ，スバルのデータが残ります。\nしかしスバルの`sale`には`NA`が入ります。\n\n最後に，`df_AB`と`df_C`を完全結合してみましょう。\n\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-32_6f84fba7e73fa3a24afd83598c187d98'}\n\n```{.r .cell-code}\ndf_full <- df_AB %>%\n    full_join(df_C, by = c(\"name\", \"term\"))\nprint(df_full)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     name term sale netincome\n1  トヨタ 2020 1000       100\n2  トヨタ 2021  900        90\n3  トヨタ 2022 1400       150\n4  ホンダ 2020  800       140\n5  ホンダ 2021  700       100\n6  ホンダ 2022  900        90\n7    日産 2020  400        NA\n8    日産 2021  500        NA\n9    日産 2022  900        NA\n10 マツダ 2020  300        NA\n11 マツダ 2021  400        NA\n12 マツダ 2022  200        NA\n13 スバル 2020   NA        30\n14 スバル 2021   NA        35\n15 スバル 2022   NA        50\n```\n:::\n:::\n\n\n`df_AB`にはトヨタ，ホンダ，日産，マツダのデータがありますが，`df_C`にはトヨタ，ホンダ，スバルのデータがあるため，\n完全結合した`df_full`にはすべての企業のデータが入ります。\nしかし，日産とマツダの`netincome`には`NA`が入り，スバルの`sale`にも`NA`が入ります。\n\nこのように，結合するデータによって，結合したデータに含まれるデータが変わるので，自分が望む結合後のデータの形を考えて，どの結合を使うかを選ぶ必要があります。\n\nついでに内部結合もやってみましょう。\n\n\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-33_d4472674ae085ed3f7021ce23d709102'}\n\n```{.r .cell-code}\ndf_inner <- df_AB %>%\n    inner_join(df_C, by = c(\"name\", \"term\"))\nprint(df_inner)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    name term sale netincome\n1 トヨタ 2020 1000       100\n2 トヨタ 2021  900        90\n3 トヨタ 2022 1400       150\n4 ホンダ 2020  800       140\n5 ホンダ 2021  700       100\n6 ホンダ 2022  900        90\n```\n:::\n:::\n\n\n予想どおり，両方のデータに含まれているトヨタとホンダだけが残り，片方のデータにしか含まれていない日産，マツダ，スバルのデータは欠落してしまいました。\nこのように内部結合は，両方のデータに存在する観測値のみを保持するため，多くのデータが欠落することになり，利用する機会があまりないです。\n\n\n## データの保存\n\n前処理が終わったデータは，ファイルとして保存しておくとよいでしょう。\nたとえば，`df_left`を`df_left.csv`というファイル名で保存するには，`readr`パッケージの`write_csv()`関数を使います。\n\n`write_csv()`関数の第1引数は保存したいオブジェクト(ここでは`df_left`)で，あとの主要な引数は，\n\n- `file`\n- `na = \"NA\"`\n- `append = FALSE`\n\nとなります。\n`file`は保存するファイル名を指定します。\n`na`は欠損値をどうするかを指定します。デフォルトでは`NA`となっています。\n`append`は，既存のファイルに追記するかどうかを指定します。基本は上書きなので，`FALSE`にしておきます。\n\n\n::: {.cell hash='prezemi_2023_03_presen_cache/revealjs/unnamed-chunk-34_61b05d74a36f602559924de5be4dc317'}\n\n```{.r .cell-code}\nwrite_csv(df_left, file = \"df_left.csv\")\n```\n:::\n\n\nこれで，作業ディレクトリに`df_left.csv`が保存されました。\n分析を進める際は，このようにして保存したデータを読み込んで使います。\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}