{
  "hash": "5158ea96883c093ae080da5f914c96bc",
  "result": {
    "markdown": "# Rによるデータ操作\n\n第5回講義の**到達目標**は、\n\n- 様々なデータをRで読み込むことができる。\n- 読み込んだデータを確認できる。\n- 基本的なデータ操作ができる。\n- 整然データの構造を理解し、データを必要な形に成形できる。\n- 複数のデータを結合できる。\n- 作成したデータを保存できる。\n\n第5回講義の**到達度検証のための課題**は、以下の通りです。\n\n1. CSVファイル、Excelファイルを読み込んで、中身を確認する。\n2. 必要なデータの抽出、変数の追加、変数の選択を行い、分析に適した形に持っていける。(`filter()`、`mutate()`,`select()`, `arrange()`, `pivot_longer()`, `pivot_wider()`)\n3. データ結合の種類を理解し、複数のデータを結合して、1つのデータフレームを作成する。(`bind_rows()`, `bind_cols()`, `left_join()`, `right_join()`, `inner_join()`, `full_join()`)\n\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-1_2bf4b122e65931034532910f24eabc85'}\n\n:::\n\n\nこの章では、Rを用いたデータ操作の基本的な方法を学びます。\nこの章は何度も読み返し、繰り返し練習してください。\nここでは、なぜRを使うと便利なのかを分かってもらうために、Excelの操作と比較する形で、Rのデータ操作の基本を学びます。\n\n## データの読み込み\n\n### CSVファイルの読み込み\n\n多くのプログラミング言語で、読み込むデータとして最も多いのが、CSV形式のファイルです。ファイルの拡張子は`.csv`です。\nCSVとは、Comma Separated Valuesの略で、カンマで区切られたデータのことです。\n次のような形をしています。\n\n```\n企業ID,決算年月,売上高\n13,2020/03,1000\n13,2021/03,1200\n13,2022/03,1500\n24,2020/03,2000\n24,2021/03,2200\n24,2022/03,2500\n33,2020/03,3000\n33,2021/03,3200\n33,2022/03,3500\n```\nこのように、値とコンマ`,`のみで構成されたファイルのため、余計な情報が入っておらず、またファイルサイズも小さく、加工が簡単なので、データのやり取りによく使われます。\n\nさっそくファイルを読み込んでみましょう。\nここでは、松浦のウェブサイトにあるデータ`keshohin_2023.csv`を読み込んでみます。\nRの場合は、`read.csv`という関数を使って、URLを直接指定して読み込むことができます。読み込んだデータを`df`という変数に代入しています。\n\nExcelの場合は、インターネット上のデータを直接取り込むことは難しいので、いったんパソコンの中に保存してから、ファイルを開くとします。\n\n:::{.callout-important}\n## Rの場合\n\n`R`でcsvファイルを読み込む最もシンプルな方法は、基本関数`read.csv()`を用いて、ファイル名やファイルを参照するURLを直接指定することです。\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-2_0a9f607d005e8ac64b026d270268a966'}\n\n```{.r .cell-code}\ndf <- read.csv(\"https://so-ichi.com/kesho_2023.csv\")\n```\n:::\n\n:::\n\n::: {.callout-tip}\n## MS Excelの場合\n\n1. URL`https://so-ichi.com/kesho_2023.csv`をブラウザに入力してファイルをダウンロードし、任意の場所に保存\n2. 「ファイル」から「開く...」をクリックして、保存したCSVファイルを選択し「開く」をクリック\n:::\n\n### Excelファイルの読み込み\n\nMS Excelのファイルは拡張子が`.xlsx`、古いMS Excelだと`.xls`です。\nRでExcelファイルを読み込むときは、`read_excel`という関数を使います。\nExcelファイルを用意するのが面倒なので、ここではこうやれば読み込めるよ、というコードだけ説明します。ファイル名は`hoge.xlsx`とします。\n\n:::{.callout-important}\n## Rの場合\n\n`R`でMS Excelのファイルを読み込むには、`readxl`パッケージの`read_excel()`関数を用います。\n\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-3_ba516d3f768f7227e2813d8584bd88d6'}\n\n```{.r .cell-code}\ndfx <- readxl::read_excel(\"hoge.xlsx\")\n```\n:::\n\n:::\n\n::: {.callout-tip}\n## MS Excelの場合\n\n1. 「ファイル」から「開く...」をクリックし、保存してあるExcelファイルを選択し「開く」をクリック\n:::\n\nMS Excelの問題点は、目的のデータがどのExcelファイルに入っていて、それがどこに保存されているのかを覚えておかないと、いちいちファイルを開いて探さないといけないことです。\n\nRだとソースコードを残すことができますので、\nどこにあるファイルを読み込んで、そこに何が入っているのかをコメントで残しておくことができます。\n\n## 読み込んだデータの確認\n\nMS Excelは読み込んだデータが画面上に表として表示されていますが、Rでは変数に代入しただけでは、画面には何も表示されません。\nそこでデータの中身を確認する関数として、次のようなものがあります。\n\n- `head()` : 最初の数行を表示させる基本関数\n- `str()` : データの構造を表示させる基本関数\n- `glimpse()` : データの構造を表示させるdplyrパッケージの関数\n- `names()` : 変数名を表示させる基本関数\n\nこれらを使って、データの中身を確認し、データの形に適した処理方法を学ぶ必要があります。\n以下では、`head()`関数を使って、データの最初の数行を表示させてから、`str()`関数でデータの中の変数とその型を確認します。\n\nExcelは目視が中心ですが、見ただけでは、文字列なのか数なのかが分からないので、やはりデータの型は確認する必要があります。\n\n:::{.callout-important}\n## Rの場合\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-4_fb5b7926f4ce71c14868b61f7e2af86b'}\n\n```{.r .cell-code}\nhead(df)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| code|name   |term    | shubetsu| ren|  sales| netincome| month|\n|----:|:------|:-------|--------:|---:|------:|---------:|-----:|\n|  641|資生堂 |1985/11 |       10|   1| 371040|     14526|    12|\n|  641|資生堂 |1986/11 |       10|   1| 375294|     13632|    12|\n|  641|資生堂 |1987/11 |       10|   1| 378977|      9014|    12|\n|  641|資生堂 |1988/11 |       10|   1| 401311|      9515|    12|\n|  641|資生堂 |1989/03 |       10|   1| 130654|      4265|     4|\n|  641|資生堂 |1990/03 |       10|   1| 456352|     11362|    12|\n\n</div>\n:::\n\n```{.r .cell-code}\nstr(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t130 obs. of  8 variables:\n $ code     : int  641 641 641 641 641 641 641 641 641 641 ...\n $ name     : chr  \"資生堂\" \"資生堂\" \"資生堂\" \"資生堂\" ...\n $ term     : chr  \"1985/11\" \"1986/11\" \"1987/11\" \"1988/11\" ...\n $ shubetsu : int  10 10 10 10 10 10 10 10 10 10 ...\n $ ren      : int  1 1 1 1 1 1 1 1 1 1 ...\n $ sales    : int  371040 375294 378977 401311 130654 456352 517252 553299 561549 549178 ...\n $ netincome: int  14526 13632 9014 9515 4265 11362 15850 16011 13290 14668 ...\n $ month    : int  12 12 12 12 4 12 12 12 12 12 ...\n```\n:::\n:::\n\n:::\n\n::: {.callout-tip}\n## MS Excelの場合\n\n画面を見て確認する。\n\n:::\n\nこのデータには，\n\n- `code` : 企業コード (文字列)\n- `name` : 企業名 (文字列)\n- `term` : 決算年月 (文字列)\n- `shubetsu` : 会計基準の種類 (数値)\n- `ren` : 連結か単体 (数値)\n- `sales` : 売上高 (数値)\n- `netincome` : 当期純利益 (数値)\n- `month` : 決算月数 (数値)\n\nが入っています。\n\n## データの整形\n\n### データ操作の基礎\n\nさあ面白くなってきました。\n次はデータを操作していきます。\nRによるデータ操作では、`tidyverse`パッケージ群の`dplyr`パッケージが大活躍します。\n\n`dplyr`パッケージの関数の中でもよく使うものに次のようなものがあります。\n\n- `select()` : 変数を選択する\n- `filter()` : データを抽出する\n- `mutate()` : 変数を追加する\n- `arrange()` : データを並び替える\n- `summarise()` : データを集計する\n- `group_by()` : データをグループ化する\n\n### パイプ演算子\n\nRでソースコードを書く際に，理解しやすく，読みやすいコードにするために非常に便利なのが，パイプ演算子`%>%`です。\nパイプ演算子`%>%`は，左側のオブジェクトを右側の関数の第一引数に渡すという処理を行います。\nたとえば，\n\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-5_e9844bd7d6986d2dd720c178240a14be'}\n\n```{.r .cell-code}\n(1 + 2) %>% sqrt()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.732051\n```\n:::\n:::\n\nと書くと，`sqrt(1 + 2)`と同じ意味になります。\nたとえば，`rnorm()`関数を使って平均0，分散1の標準正規分から100個のデータを作りたいとします。\n`rnorm()`関数は3つの引数を取ります。\n\n1. データの個数\n2. 平均\n3. 標準偏差\n\nしたがって，`rnorm(100, 0, 1)`と書くと，平均0，分散1の標準正規分布から100個のデータを取り出すことができます。\nパイプ演算子を使うと，\n\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-6_e8f3bd5d96144cd33a51c43f6a9b0e05'}\n\n```{.r .cell-code}\n100 %>% rnorm(mean = 0, sd = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] -0.413650214  0.135845505 -0.880369179 -0.626775788  0.947561162\n  [6] -0.931267997 -0.060645562  0.772570886  0.647924181  1.757970332\n [11]  0.112580537 -0.589113001 -1.284279987  1.439454398  0.583716103\n [16]  0.273968673  1.221706850  1.312342764 -0.146998701  0.193327798\n [21] -1.638641788 -1.275899887 -0.797048174  0.381481984 -1.751460408\n [26]  1.827450808 -0.789164822  1.121482530 -1.559700073  0.200030623\n [31] -0.857194216 -1.158500709  0.309199058  0.213006653  0.829293464\n [36] -0.023504179  0.966017461 -1.219799112 -0.052262848 -0.943484230\n [41]  0.664065492  1.615092671 -1.040622806  0.201302179  1.799894856\n [46] -0.996238379 -0.797047235  0.319117225  1.844458412 -1.150062998\n [51] -1.119349690  1.411150399  0.008681069  1.434869026  0.385200392\n [56] -0.115712452  1.781301178 -0.017207484  0.334870308 -0.756996814\n [61] -0.247786830  0.313502543 -1.291572405 -0.100233874 -0.587611178\n [66] -1.553340083  0.569076881 -0.305865565 -1.404945270 -0.344700849\n [71] -1.216846439  0.980009308  0.543523941  0.350888949 -0.773730408\n [76] -1.556930033  1.026219374 -1.576401043 -1.578111252  1.289721881\n [81]  0.676040785 -0.683127165 -1.382274205 -2.340489424 -0.210865983\n [86] -0.491302348  0.444841572 -0.083576141  0.900983420 -0.320987165\n [91] -0.138122507 -0.931197563 -0.759903052  1.348804258 -1.339634161\n [96]  0.667756409  0.054920524  0.674046070 -1.470349784  0.106193200\n```\n:::\n:::\n\nとなります。\nこれは`rnorm()`関数の第1引数がデータの個数なので，そこに`100`を渡しています。\nここで平均に値を渡したい場合を考えます。\n`mean`引数は第2引数なので，パイプ演算子では自動で渡してくれません。\nそこで`.`を使って渡す場所を指定してあげます。\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-7_355ebfabf4908b24710c85773ee09938'}\n\n```{.r .cell-code}\n100 %>% rnorm(100, mean =. , sd = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1]  99.93712 100.09800  98.89290  97.25350 100.17757 101.99301 100.75196\n  [8]  99.80329 100.28988  99.76684  97.72141  99.55716  99.66922 100.52017\n [15]  98.47999 100.08957  99.35533  97.26327  99.23523 100.25936  99.59122\n [22]  98.55058 100.54817  99.55084  99.15277 101.37219 100.10068  99.71226\n [29] 100.42949 101.11426 100.66748 100.26576  99.89811  99.78636 101.22749\n [36]  98.57698  98.70739  99.82663 100.32470 100.27921  99.99165  99.98171\n [43]  99.42976  99.61572  99.94501 100.62342 100.12115  99.07738  96.55018\n [50]  99.48788  97.94108  99.39733  97.93123  99.29085  99.42431  99.83017\n [57] 100.03964 100.03923  98.77049  99.27931 100.38654  99.96088  99.28632\n [64] 101.61099 101.33322 100.82902  99.42948 101.75104 101.02049 100.01756\n [71] 100.30804 100.58522 100.81851  99.10258 100.93089  98.96803 100.05511\n [78] 100.06480 101.53919 100.55392 100.34708 100.45779  99.39029 100.10197\n [85] 101.04083 100.26527  99.10376  98.63165  99.36274  99.61306  99.71467\n [92]  99.92163 101.20766  99.89143 100.80439  99.65069 101.91260  98.87894\n [99] 100.60744  99.99534\n```\n:::\n:::\n\nこれで平均100，標準偏差1の正規分布から100個のデータを取り出せました。\n\n\nこれだけだとパイプ演算子`%>%`の便利さが伝わらないので，たとえば次のような処理を考えてみましょう。\n\n1. 2020年のデータを抜き出し，\n2. 売上高当期純利益率を計算し，\n3. 産業グループごとに平均を計算する\n4. 利益率が高い順番に並び替える\n\nをパイプ演算子を使って書くと，\n\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-8_f0317671f3fb79ab1609cd99cfdfb62a'}\n\n```{.r .cell-code}\ndf <- df %>%\n    filter(term == \"2020\") %>% # 2020年のみ\n    mutate( # 新しい変数を作成\n        ratio = netincome / sales # 売上高利益率\n        ) %>%\n    group_by(sangyo) %>% # 産業グループごとに\n    summarise( # 平均を計算\n        mean_ratio = mean(ratio) # 利益率の平均\n        ) %>%\n    arrange(desc(mean_ratio)) # 利益率の高い順に並び替え\n```\n:::\n\nのように，上から順番に処理を実行し，次に渡す，というプロセスが分かりやすく，読みやすいコードができました。\nコメントも残しておけば，後から見返したときにも分かりやすいですし，他人によんでもらうときも親切ですね。\nしたがって，以下ではパイプ演算子を駆使して，データ操作を行っていきます。\n\n\n### 新しい変数を作成する `mutate` {.unnumbered}\n\n新しい変数を作成するには，`dplyr`パッケージの`mutate()`関数を使います。\n先ほど読みこんだデータから，当期純利益を売上高で除して売上高当期純利益率を計算して，`ratio`という変数を作ってみましょう。\n\n:::{.callout-important}\n## Rの場合\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-9_d88807febf6d3937c8f1156a987ac0f1'}\n\n```{.r .cell-code}\ndf <- df %>%\n    mutate( # 新しい変数を作成\n        ratio = netincome / sales # 売上高利益率\n        )\n```\n:::\n\n:::\n\n::: {.callout-tip}\n## MS Excelの場合\n\n`I1`のセルに変数名を表す`ratio`と入力する。\nF列の`sale`とG列の`netincome`を使って，`I2`のセルに\n\n`= G2 / F2`\n\nとし，`I2`セルの右下の四角をダブルクリックすると，自動で下のセルにも同じ計算がコピーされる。\n:::\n\n次に，ある変数の値に応じて異なる値をとる変数を作るには，`mutate()`関数と`ifelse()`関数を同時に使います。`ifelse()`関数は次のような引数を取ります。\n\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-10_8ac7f80f6568eab8d43c4f2edb897997'}\n\n```{.r .cell-code}\nifelse(条件, 条件が真のときの値, 条件が偽のときの値)\n```\n:::\n\n\n先ほど計算した売上高当期純利益率が5%以上ならば「高い」，そうでなければ「低い」という変数`highlow`を作ってみましょう。\n\n:::{.callout-important}\n## Rの場合\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-11_0acf6f1b0061f528e0ab4fd7fb44b67a'}\n\n```{.r .cell-code}\ndf <- df %>%\n    mutate( # 新しい変数を作成\n        highlow = ifelse(ratio >= 0.05, \"高い\", \"低い\") # 売上高利益率\n        )\n```\n:::\n\n:::\n\n::: {.callout-tip}\n## MS Excelの場合\n`J1`セルに`highlow`と入力する。\n`J2`セルに\n\n` = if(I2 >= 0.05, \"高い\", \"低い\")`\n\nと入力し，`J2`セルの右下の四角をダブルクリックすると，自動で下のセルにも同じ計算がコピーされる。\n:::\n\nExcelだとセルの移動や変数名の入力，計算式の入力，セルのコピーといった作業で，キーボードとマウスを行ったり来たりする必要があり，若干面倒です。\n\nついでに，`mutate()`関数を使って，長すぎる企業名を短くしてみます。\nここでは「ポーラ・オルビスホールディングス」を「ポーラ」と略してみます。\n`mutate()`と`ifelse`を使って，`name`変数の値が「ポーラ・オルビスホールディング」ならば「ポーラ」という値をとる変数`name`上書きします。を作ってみましょう。\n\n:::{.callout-important}\n## Rの場合\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-12_e2430ac881cf7738fd7ce7bdbd25d11b'}\n\n```{.r .cell-code}\ndf <- df %>%\n    mutate( # 新しい変数を作成\n        name = ifelse(\n            name == \"ポーラ・オルビスホールディング\", \"ポーラ\", name) # 企業名\n        )\n```\n:::\n\n:::\n\n\n### データを抽出する `filter` {.unnumbered}\n\nデータを抽出するには，`dplyr`パッケージの`filter()`関数を使います。\n`filter()`関数は，次のような引数を取ります。\n\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-13_051d8073fd030d83ad0df01fd7c6f110'}\n\n```{.r .cell-code}\nfilter(データ, 条件)\n```\n:::\n\n\n先ほど作成した`ratio2`が「高い」企業だけを抽出してみましょう。\n`filter()`関数の中の条件は，`==`を使って，`\"高い\"`という文字列と一致するかどうかを確認しています。\nここでは，`highlow`変数の値が`\"高い\"`と一致する企業だけを抽出し，`df_high`という変数に代入しています。\n\n:::{.callout-important}\n## Rの場合\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-14_3374ac712d1702afc73b9ad576f21f2e'}\n\n```{.r .cell-code}\ndf_high <- df %>%\n    filter(highlow == \"高い\") # 条件\n```\n:::\n\n:::\n\n::: {.callout-tip}\n## MS Excelの場合\nhighlow変数のあるJ列をクリックして枠を移動させ，上の「ホーム」メニューから「並び替えとフィルター」をクリックし，「フィルター」をクリックする。\nすると，変数名highlowのヨコに漏斗のようなマークが出るので，それをクリックすると，記録されたデータの種類が出てくるので，「高い」だけにチェックが入った状態にする。\n:::\n\nExcelのクリック回数が増えてきましたね。\n\n`filter()`関数の中で指定する条件は，\n\n- `==` : 一致する\n- `!=` : 一致しない\n- `>=`や`<=` : 以上や以下\n- `>`や`<` : より大きいや小さい\n- `%in%` : いずれかに一致する\n\nなどがあります。またこれらの条件を組み合わせることもできます。\nその場合は，以下のように`&`や`|`を使います。\n\n- `&` : かつ\n- `|` : または\n\nたとえば，資生堂と花王を抽出したり，売上高当期純利益率が5%以上かつ売上高が1000億円以上の企業を抽出するには，\n次のように書きます。\n\n:::{.callout-important}\n## Rの場合\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-15_817c0102d5aae5b37911c8bb2891503c'}\n\n```{.r .cell-code}\ndf_shiseido_kao <- df %>%\n    filter(name %in% c(\"資生堂\", \"花王\")) # 2社だけ抽出\ndf_high2 <- df %>%\n    filter(ratio >= 0.05 & sales >= 1000) # 2条件を同時に満たす\n```\n:::\n\n:::\n\n\n\n### 変数を選択する `select` {.unnumbered}\n\nデータの中から必要な変数だけを選択するには，`dplyr`パッケージの`select()`関数を使います。\nたとえば，先ほど作成した`df`から，企業コード，企業名，売上高当期純利益率の3つの変数だけを選択してみましょう。\n\n:::{.callout-important}\n## Rの場合\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-16_23fc366faa4601a6000c1573564d4c67'}\n\n```{.r .cell-code}\ndf3 <- df %>%\n    select(code, name, ratio) # 3つの変数だけ選択\n```\n:::\n\n:::\n\n::: {.callout-tip}\n## MS Excelの場合\nオリジナルのデータをコピーして，下のタブから別のシートを選択し，そこに貼り付ける。\n\n貼り付けたデータから`code`と`name`と`ratio`以外の列を削除する。\n:::\n\nMS Excelだと，不要なデータを削除するのが怖い作業で，必要になったときにまた元のデータを読み込まないといけないので，面倒ですし，ミスのもとです。\n\n`select()`関数の中で使えるものには，以下のようなものがあります。\nとても便利なので，覚えておくとよいでしょう。\n\n- `-` : 除外する (`-ratio`とかくと`ratio`以外を選択)\n- `:` : 連続する変数を選択 (`code:ren`と書くと`code`から`ren`までを選択)\n- `starts_with()` : ある文字列で始まる変数を選択\n- `ends_with()` : ある文字列で終わる変数を選択\n\nたとえば，`mutate()`で新しい変数を作る場合に，変数名に法則性をつけておけば，`starts_with()`を使って一気に変数を選択することができます。\nたとえば，比率を表す変数は`ratio`で始まるように統一しておく，基準化した変数には`_K`を最後に付けておく，などです。\n\n### データを並び替える `arrange` {.unnumbered}\n\nデータを並び替えるには，`dplyr`パッケージの`arrange()`関数を使います。\nたとえば，先ほど作成した`df`から，売上高当期純利益率を並び替えてみましょう。\n\n:::{.callout-important}\n## Rの場合\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-17_b3ff4d9910bc1457e5345bf171985c98'}\n\n```{.r .cell-code}\ndf %>%\n    select(name, ratio) %>% # 2つの変数だけ選択\n    arrange(ratio) %>%\n    head()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|name   |      ratio|\n|:------|----------:|\n|ポーラ | -0.4349581|\n|資生堂 | -0.0757638|\n|資生堂 | -0.0385906|\n|資生堂 | -0.0216680|\n|資生堂 | -0.0138412|\n|資生堂 | -0.0126617|\n\n</div>\n:::\n:::\n\n:::\n小さい順に並び替えられました。\n大きい順にするには，`desc()`関数を使います。\nついでに`knitr`パッケージの`kabble()`関数で表を見やすく加工してみます。\n\n:::{.callout-important}\n## Rの場合\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-18_d886c769b57c7d1ccbd3d98ee4c41e30'}\n\n```{.r .cell-code}\ndf %>%\n    select(name, ratio) %>% # 2つの変数だけ選択\n    arrange(desc(ratio)) %>%\n    head(10) %>% # 先頭の10行\n    knitr::kable(booktabs = TRUE) # 表をきれいに表示\n```\n\n::: {.cell-output-display}\n|name           |     ratio|\n|:--------------|---------:|\n|ポーラ         | 0.1110647|\n|花王           | 0.1019213|\n|花王           | 0.0987028|\n|花王           | 0.0986613|\n|ユニ・チャーム | 0.0929384|\n|花王           | 0.0912752|\n|ポーラ         | 0.0895507|\n|ユニ・チャーム | 0.0891383|\n|ユニ・チャーム | 0.0890311|\n|ユニ・チャーム | 0.0869777|\n:::\n:::\n\n:::\nこれでどの企業のどの年度の売上高当期純利益率が大きいのかが一目瞭然になりました。\n\nMS Excelだと，\n\n::: {.callout-tip}\n## MS Excelの場合\n\n「ホーム」メニューから「並び替えとフィルター」をクリックし，「昇順」をクリックする。\n\n必要なデータだけ選択してコピペすれば，表が完成します。\n:::\n\nとなります。\n簡単ですが，MS Excelの並び替えは注意が必要で，並び替えた後にデータを追加すると，並び替えが解除されてしまい，元に戻せなくなったり，空列があると並び替えがうまくいかなかったりします。\n\n\n### long形式とwide形式\n\n人間には読みやすいけれどパソコンは読みにくい，というデータの形式があります。\n例えば下の表を見てみましょう。\n\n| 地点 |   6時    |   12時   |   18時   |\n|:----:|:--------:|:--------:|:--------:|\n| 札幌 | 12℃  | 15℃  | 13℃  |\n| 大阪 | 20℃  |  24℃  |  22℃  |\n| 福岡 |  23℃  | 25℃  | 25℃  |\n\nこのような形のデータをワイド形式(wide)といいます。\n天気予報で見かけそうなこの表は，人間にとっては分かりやすいですが，実はコンピュータにとっては，分かりにくいものです。\nコンピュータが理解しやすいデータとして表すなら，次のような表になります。\n\n| 地点 | 時間 |  気温(℃) |\n|:----:|:----:|:-------:|\n| 札幌 | 6時  |   12    |\n| 札幌 | 12時 |   15    |\n| 札幌 | 18時 |   13    |\n| 大阪 | 6時  |   20    |\n| 大阪 | 12時 |    24    |\n| 大阪 | 18時 |    22    |\n| 福岡 | 6時  |    23    |\n| 福岡 | 12時 |   25    |\n| 福岡 | 18時 |   25    |\n\nこのような形式のデータをロング型(long)といいます。\nこのロング型のうち，一定のルールに従って作成されたデータを**整然データ(tidy data)**といい，Rでは，この整然データを扱うことが多いです。\n\nR神Hadley Wickham氏は，データの型を理解することを，データ分析の第一歩とし，その一貫として整然データという考え方を提唱しています。 整然データとは，次のような原則に従って構築されたデータのことです(Wickham, 2014) 参考[https://id.fnshr.info/2017/01/09/tidy-data-intro/](https://id.fnshr.info/2017/01/09/tidy-data-intro/)。\n\n1.  個々の変数 (variable) が1つの列 (column) をなす。\n2.  個々の観測 (observation) が1つの行 (row) をなす。\n3.  個々の観測の構成単位の類型 (type of observational unit) が1つの表 (table) をなす。\n4.  個々の値 (value) が1つのセル (cell) をなす\n\n上の表は，地点，時間，天気，気温の4つの変数があり1つの列をつくっています(ルール1)。 大阪12時の天気は雨，気温は12℃といったように1つの行が1つの観測を表しています(ルール2)。 このデータには種類の異なる観測はない(ルール3)。 また，各セルには1つの値が入っています(ルール4)。 よって，これが整然データとなります。\n\n上のロング型の天気データを使って，ロングからワイド，ワイドからロングの操作を学びましょう。\n\nまずデータを作ります。\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-19_909a2d601efb86c45c5b715fb8f6b0ed'}\n\n```{.r .cell-code}\ndf_weather <- data.frame(\n    place = c(\"札幌\",\"札幌\",\"札幌\",\"大阪\",\"大阪\",\"大阪\",\"福岡\",\"福岡\",\"福岡\"), # 各地を3個ずつ\n    time = rep(c(\"6時\", \"12時\", \"18時\"),3),\n    temp = c(12,15,13,20,24,22,23,25,25)\n)\nprint(df_weather)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  place time temp\n1  札幌  6時   12\n2  札幌 12時   15\n3  札幌 18時   13\n4  大阪  6時   20\n5  大阪 12時   24\n6  大阪 18時   22\n7  福岡  6時   23\n8  福岡 12時   25\n9  福岡 18時   25\n```\n:::\n:::\n\n\nこれはロング型の整然データとなります。\n\n### ロングからワイド `pivot_wider` {.unnumbered}\n\nRで使うならこのままでよいのですが，あえてこれをワイド型に変えてみましょう。\n\n教科書で使用されている`spread()`は「根本的に設計ミスってた」と公式で発表されているので，R神が作った`pivot_wider()`を使います。widerという名前の通り，ワイド型に変換する関数です。\n\n`pivot_wider()`の引数は，`names_from`と`values_from`です。`names_from`は，ワイド型に変換するときに，どの変数を列にするかを指定します。`values_from`は，ワイド型に変換するときに，どの変数の値を使うかを指定します。\n\n以下のコードでは，`time`変数の値を列に，`temp`変数の値を値にして，`df_wide`という変数に代入しています。\n\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-20_3389183b1cb58466de226b09ca1fc73b'}\n\n```{.r .cell-code}\ndf_wide <- df_weather %>%\n    pivot_wider(names_from = time, values_from = temp)\nprint(df_wide)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 4\n  place `6時` `12時` `18時`\n  <chr> <dbl>  <dbl>  <dbl>\n1 札幌     12     15     13\n2 大阪     20     24     22\n3 福岡     23     25     25\n```\n:::\n:::\n\n\nこれでワイド型に変換できました。\n\n### ワイドからロング `pivot_longer` {.unnumbered}\n\n\n次に，このワイド型のデータをロング型に変換してみます。\n教科書では，`tidyr`の`gather()`を使っていますが，これも`wider()`と同じ問題を持っているので，R神による`pivot_longer()`を使います。\n\n`pivot_longer()`の引数は，`cols`と`names_to`と`values_to`です。\n\n- `cols`は，ロング型に変換するときに，どの変数を行にするかを指定\n- `names_to`は，ロング型に変換するときに，どの変数の値を使うかを指定\n- `values_to`は，ロング型に変換するときに，どの変数の値を使うかを指定\n\n以下のコードでは，`6時`，`12時`，`18時`の3つの変数を行に，`time`という変数の値を列に，`temp`という変数の値を値にして，`df_long`という変数に代入しています。\n\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-21_db26a6f0b4422f1d6d64739fc8607349'}\n\n```{.r .cell-code}\ndf_long <- df_wide %>%\n    pivot_longer(\n        cols = c(\"6時\", \"12時\", \"18時\"), # 縦にする変数\n        names_to = \"time\", # 縦にした変数名\n        values_to = \"temp\") # 値\nprint(df_long)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 3\n  place time   temp\n  <chr> <chr> <dbl>\n1 札幌  6時      12\n2 札幌  12時     15\n3 札幌  18時     13\n4 大阪  6時      20\n5 大阪  12時     24\n6 大阪  18時     22\n7 福岡  6時      23\n8 福岡  12時     25\n9 福岡  18時     25\n```\n:::\n:::\n\n\n元のロング型に戻りました。\n\n### データの結合\n\n別々のデータを結合させて使いたいことはよくあります。\n例えば，次のようなデータを結合させる場合を考えてみましょう。\n\n#### 表A {.unnumbered}\n\n| name | term | sale |\n|:----|----:|----:|\n|トヨタ | 2020 | 1000 |\n|トヨタ | 2021 | 900 |\n|トヨタ | 2022 | 1400 |\n|ホンダ | 2020 | 800 |\n|ホンダ | 2021 | 700 |\n|ホンダ | 2022 | 900 |\n\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-22_679d2c216310134cba3465c0d14b0be8'}\n\n```{.r .cell-code}\ndf_A <- data.frame(\n    name = c(\"トヨタ\", \"トヨタ\", \"トヨタ\", \"ホンダ\", \"ホンダ\", \"ホンダ\"),\n    term = c(2020, 2021, 2022, 2020, 2021, 2022),\n    sale = c(1000, 900, 1400, 800, 700, 900)\n)\n```\n:::\n\n\n#### 表B {.unnumbered}\n\n| name | term | sale |\n|:----|----:|----:|\n|日産 | 2020 | 400 |\n|日産 | 2021 | 500 |\n|日産 | 2022 | 900 |\n|マツダ | 2020 | 300 |\n|マツダ | 2021 | 400 |\n|マツダ | 2022 | 200 |\n\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-23_09a9827d9b419ddabc2226cb2a384b29'}\n\n```{.r .cell-code}\ndf_B <- data.frame(\n    name = c(\"日産\", \"日産\", \"日産\", \"マツダ\", \"マツダ\", \"マツダ\"),\n    term = c(2020, 2021, 2022, 2020, 2021, 2022),\n    sale = c(400, 500, 900, 300, 400, 200)\n)\n```\n:::\n\n\n#### 表C {.unnumbered}\n\n| name | term | netincome |\n|:----|----:|----:|\n|トヨタ | 2020 | 100 |\n|トヨタ | 2021 | 90 |\n|トヨタ | 2022 | 150 |\n|ホンダ | 2020 | 140 |\n|ホンダ | 2021 | 100 |\n|ホンダ | 2022 | 90 |\n|スバル | 2020 | 30 |\n|スバル | 2021 | 35 |\n|スバル | 2022 | 50 |\n\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-24_88cb351008aea34d8714850c75ffebce'}\n\n```{.r .cell-code}\ndf_C <- data.frame(\n    name = c(\"トヨタ\", \"トヨタ\", \"トヨタ\", \"ホンダ\", \"ホンダ\", \"ホンダ\", \"スバル\", \"スバル\", \"スバル\"),\n    term = c(2020, 2021, 2022, 2020, 2021, 2022, 2020, 2021, 2022),\n    netincome = c(100, 90, 150, 140, 100, 90, 30, 35, 50)\n)\n```\n:::\n\n\n\nこの3つのデータを結合させる場合を考えます。\nまず表Aと表Bは同じ変数をもつデータなので，これらを結合させるには，縦につなげる必要があります。\nこのような結合を**縦結合**とか連結といいます。\n縦結合は，`dplyr`パッケージの`bind_rows()`関数を使います。\n\n\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-25_92c7483ae5eb6fdcbf88393fd62d97c4'}\n\n```{.r .cell-code}\ndf_AB <- bind_rows(df_A, df_B)\nprint(df_AB)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     name term sale\n1  トヨタ 2020 1000\n2  トヨタ 2021  900\n3  トヨタ 2022 1400\n4  ホンダ 2020  800\n5  ホンダ 2021  700\n6  ホンダ 2022  900\n7    日産 2020  400\n8    日産 2021  500\n9    日産 2022  900\n10 マツダ 2020  300\n11 マツダ 2021  400\n12 マツダ 2022  200\n```\n:::\n:::\n\n縦に結合できたので，トヨタ，ホンダ，日産，マツダのデータが入ったデータベース`df_AB`ができました。\n\n次に，この`df_AB`と`df_C`を結合させます。\n`df_C`は`netincome`という`df_AB`にはない変数があり，異なる変数をもつデータ同士の結合となります。\nこれらを結合させるには，横につなげる必要があります。\nこのような結合を**結合**といいます。\n\n結合には，\n\n- **内部結合**(inner join)\n- **外部結合**(outer join)\n\nがあり，外部結合には，\n\n- **完全結合**(full join)\n- **左結合**(left join)\n- **右結合**(right join)\n\nがあります。\n\n内部結合は**両方のデータベースに存在する観測値のみを保持**するため，多くのデータが欠落することになりますが，**外部結合**は、少なくとも1つのテーブルに存在する観測値を保持するので，大部分のデータが欠落することにはなりません。\n\n3つの外部結合の特徴は次の通りです。\n\n- **完全結合**は、xとyのすべての観測値を保持します。\n- **左結合**は、xのすべての観測値を保持します。\n- **右結合**は、yのすべての観測値を保持します。\n\nR神の神書籍[R for Data Science (2e)](https://r4ds.hadley.nz/)の図がわかりやすいので，ここで紹介します。\n\n![外部結合の例](img/R4D_join.png)\n\n内部結合と3つの外部結合をベン図で表すとこうなります。\n\n![外部結合のベン図](img/R4D_outer_join.png)\n\n最もよく使われる結合は**左結合**です。\n元データに他のデータを結合する場合，元データに含まれるデータのみ保持したい場合が多いので，追加データを調べるときはいつもこれを使います。\n左結合はデフォルトの結合であるべきで、他の結合を選択する強い理由がない限り、これを使用します。\n\nでは，`df_AB`と`df_C`を左結合してみましょう。\n結合する際にキーとなる変数を指定する必要があります。\nここでは`name`と`term`の2つの変数をキーとして指定します。\nこうすることで，`name`と`term`が一致する観測値を結合します。\n\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-26_57f149f568249c78e09340ebfa4175ec'}\n\n```{.r .cell-code}\ndf_left <- df_AB %>%\n    left_join(df_C, by = c(\"name\", \"term\"))\nprint(df_left)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     name term sale netincome\n1  トヨタ 2020 1000       100\n2  トヨタ 2021  900        90\n3  トヨタ 2022 1400       150\n4  ホンダ 2020  800       140\n5  ホンダ 2021  700       100\n6  ホンダ 2022  900        90\n7    日産 2020  400        NA\n8    日産 2021  500        NA\n9    日産 2022  900        NA\n10 マツダ 2020  300        NA\n11 マツダ 2021  400        NA\n12 マツダ 2022  200        NA\n```\n:::\n:::\n\n\n`df_AB`にはトヨタ，ホンダ，日産，マツダのデータがありますが，`df_C`には日産とマツダのデータがなく，スバルのデータがあります。\nそのため左結合すると，日産とマツダの`netincome`には`NA`が入り，スバルは欠落します。\n\n\n`df_AB`と`df_C`を右結合してみましょう。\n\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-27_f04b85c2d707c59ced37c2215e0231c9'}\n\n```{.r .cell-code}\ndf_right <- df_AB %>%\n    right_join(df_C, by = c(\"name\", \"term\"))\nprint(df_right)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    name term sale netincome\n1 トヨタ 2020 1000       100\n2 トヨタ 2021  900        90\n3 トヨタ 2022 1400       150\n4 ホンダ 2020  800       140\n5 ホンダ 2021  700       100\n6 ホンダ 2022  900        90\n7 スバル 2020   NA        30\n8 スバル 2021   NA        35\n9 スバル 2022   NA        50\n```\n:::\n:::\n\n\n`df_C`には日産とマツダのデータがなく，トヨタとホンダとスバルのデータがあります。\nそのため右結合すると日産とマツダのデータが欠落し，`df_C`に含まれていたトヨタ，ホンダ，スバルのデータが残ります。\nしかしスバルの`sale`には`NA`が入ります。\n\n最後に，`df_AB`と`df_C`を完全結合してみましょう。\n\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-28_2e1bb8836ac3604a4d062fb469e1d85c'}\n\n```{.r .cell-code}\ndf_full <- df_AB %>%\n    full_join(df_C, by = c(\"name\", \"term\"))\nprint(df_full)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     name term sale netincome\n1  トヨタ 2020 1000       100\n2  トヨタ 2021  900        90\n3  トヨタ 2022 1400       150\n4  ホンダ 2020  800       140\n5  ホンダ 2021  700       100\n6  ホンダ 2022  900        90\n7    日産 2020  400        NA\n8    日産 2021  500        NA\n9    日産 2022  900        NA\n10 マツダ 2020  300        NA\n11 マツダ 2021  400        NA\n12 マツダ 2022  200        NA\n13 スバル 2020   NA        30\n14 スバル 2021   NA        35\n15 スバル 2022   NA        50\n```\n:::\n:::\n\n\n`df_AB`にはトヨタ，ホンダ，日産，マツダのデータがありますが，`df_C`にはトヨタ，ホンダ，スバルのデータがあるため，\n完全結合した`df_full`にはすべての企業のデータが入ります。\nしかし，日産とマツダの`netincome`には`NA`が入り，スバルの`sale`にも`NA`が入ります。\n\nこのように，結合するデータによって，結合したデータに含まれるデータが変わるので，自分が望む結合後のデータの形を考えて，どの結合を使うかを選ぶ必要があります。\n\nついでに内部結合もやってみましょう。\n\n\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-29_13e50e05594c804b2d8c8a4613540f89'}\n\n```{.r .cell-code}\ndf_inner <- df_AB %>%\n    inner_join(df_C, by = c(\"name\", \"term\"))\nprint(df_inner)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    name term sale netincome\n1 トヨタ 2020 1000       100\n2 トヨタ 2021  900        90\n3 トヨタ 2022 1400       150\n4 ホンダ 2020  800       140\n5 ホンダ 2021  700       100\n6 ホンダ 2022  900        90\n```\n:::\n:::\n\n\n予想どおり，両方のデータに含まれているトヨタとホンダだけが残り，片方のデータにしか含まれていない日産，マツダ，スバルのデータは欠落してしまいました。\nこのように内部結合は，両方のデータに存在する観測値のみを保持するため，多くのデータが欠落することになり，利用する機会があまりないです。\n\n\n## データの保存\n\n前処理が終わったデータは，ファイルとして保存しておくとよいでしょう。\nたとえば，`df_left`を`df_left.csv`というファイル名で保存するには，`readr`パッケージの`write_csv()`関数を使います。\n\n`write_csv()`関数の第1引数は保存したいオブジェクト(ここでは`df_left`)で，あとの主要な引数は，\n\n- `file`\n- `na = \"NA\"`\n- `append = FALSE`\n\nとなります。\n`file`は保存するファイル名を指定します。\n`na`は欠損値をどうするかを指定します。デフォルトでは`NA`となっています。\n`append`は，既存のファイルに追記するかどうかを指定します。基本は上書きなので，`FALSE`にしておきます。\n\n\n::: {.cell hash='presemi2023_04_cache/html/unnamed-chunk-30_0c216219d99c15d9e3232f16853a8c06'}\n\n```{.r .cell-code}\nwrite_csv(df_left, file = \"df_left.csv\")\n```\n:::\n\n\nこれで，作業ディレクトリに`df_left.csv`が保存されました。\n分析を進める際は，このようにして保存したデータを読み込んで使います。\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}